/**
 * AutoTrainingSchemas - MongoDB Schemas for Auto-Training Data
 * 
 * Defines database schemas and indexes for:
 * - Tenant training data and crawled content
 * - Training sessions and status tracking
 * - Job metrics and scheduler data
 * - Knowledge base items with source attribution
 */

const mongoose = require('mongoose');

// Tenant Training Data Schema
const TenantTrainingDataSchema = new mongoose.Schema({
    tenantId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    websiteUrl: {
        type: String,
        required: true
    },
    
    // Crawl Results
    crawlResults: {
        baseUrl: String,
        crawledAt: Date,
        pages: [{
            url: String,
            title: String,
            description: String,
            keywords: String,
            
            headings: {
                h1: [String],
                h2: [String],
                h3: [String]
            },
            
            content: {
                main: String,
                article: String,
                body: String
            },
            
            navigation: [{
                text: String,
                href: String
            }],
            
            footer: String,
            contactInfo: mongoose.Schema.Types.Mixed,
            
            jsonLd: [mongoose.Schema.Types.Mixed],
            
            openGraph: {
                title: String,
                description: String,
                type: String,
                image: String
            },
            
            businessElements: {
                prices: [String],
                menuItems: [String],
                services: [String],
                hours: [String]
            },
            
            crawledAt: Date,
            wordCount: Number,
            images: [{
                src: String,
                alt: String,
                title: String
            }]
        }],
        
        structuredData: mongoose.Schema.Types.Mixed,
        businessInfo: mongoose.Schema.Types.Mixed,
        siteMetadata: mongoose.Schema.Types.Mixed,
        errors: [{
            url: String,
            error: String,
            timestamp: Date
        }]
    },
    
    // Business Analysis Results
    businessAnalysis: {
        detectedType: {
            type: String,
            enum: ['restaurant', 'clinic', 'ecommerce', 'service', 'fitness', 'education', 'unknown'],
            default: 'unknown'
        },
        confidence: {
            type: Number,
            min: 0,
            max: 1
        },
        scores: mongoose.Schema.Types.Mixed,
        extractedInfo: mongoose.Schema.Types.Mixed,
        reasoning: [String],
        alternativeTypes: [{
            type: String,
            confidence: Number,
            reason: String
        }]
    },
    
    // Generated Knowledge Base
    knowledgeBase: {
        businessType: String,
        generatedAt: Date,
        version: {
            type: String,
            default: '1.0'
        },
        autoGenerated: {
            type: Boolean,
            default: true
        },
        
        items: [{
            id: String,
            type: {
                type: String,
                enum: ['faq', 'contact', 'hours', 'service', 'product']
            },
            category: String,
            question: String,
            answer: String,
            keywords: [String],
            source: String,
            confidence: Number,
            createdAt: Date,
            autoGenerated: Boolean
        }],
        
        faqs: [{
            id: String,
            question: String,
            answer: String,
            category: String,
            source: String,
            confidence: Number,
            createdAt: Date,
            autoGenerated: Boolean
        }],
        
        contactInfo: {
            businessName: String,
            phone: String,
            email: String,
            address: String,
            website: String
        },
        
        businessHours: [String],
        services: [mongoose.Schema.Types.Mixed],
        products: [mongoose.Schema.Types.Mixed],
        policies: [mongoose.Schema.Types.Mixed],
        
        sources: [{
            url: String,
            title: String,
            lastCrawled: Date,
            wordCount: Number
        }],
        
        statistics: {
            totalItems: Number,
            totalFAQs: Number,
            totalServices: Number,
            totalProducts: Number,
            pagesProcessed: Number,
            confidence: Number,
            hasContact: Boolean,
            hasHours: Boolean,
            completeness: Number
        },
        
        specialFeatures: [String]
    },
    
    // Tenant Configuration
    tenantConfig: {
        businessType: String,
        confidence: Number,
        autoConfigured: {
            type: Boolean,
            default: true
        },
        configuredAt: Date,
        
        enabledFeatures: {
            bookings: Boolean,
            orders: Boolean,
            slots: Boolean,
            payments: Boolean,
            analytics: Boolean,
            menu: Boolean,
            delivery: Boolean,
            dietary: Boolean,
            appointments: Boolean,
            doctors: Boolean,
            insurance: Boolean,
            products: Boolean,
            cart: Boolean,
            shipping: Boolean,
            consultation: Boolean,
            portfolio: Boolean,
            quotes: Boolean,
            classes: Boolean,
            membership: Boolean,
            trainers: Boolean,
            courses: Boolean,
            enrollment: Boolean,
            faculty: Boolean
        },
        
        primaryColor: String,
        welcomeMessage: String,
        
        features: mongoose.Schema.Types.Mixed,
        autoResponses: [{
            keywords: [String],
            response: String
        }],
        
        systemPrompts: {
            main: String,
            context: mongoose.Schema.Types.Mixed
        },
        
        businessContext: mongoose.Schema.Types.Mixed,
        configurationReasoning: [String]
    },
    
    // Training Metadata
    sessionId: String,
    trainedAt: Date,
    autoGenerated: {
        type: Boolean,
        default: true
    },
    updateType: {
        type: String,
        enum: ['initial', 'incremental', 'manual'],
        default: 'initial'
    },
    
    // Tracking
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    },
    lastUpdated: Date,
    
    // Status
    status: {
        type: String,
        enum: ['training', 'completed', 'failed', 'refreshing'],
        default: 'training'
    }
}, {
    timestamps: true,
    collection: 'tenant_training_data'
});

// Training Sessions Schema
const TrainingSessionSchema = new mongoose.Schema({
    sessionId: {
        type: String,
        required: true,
        unique: true,
        index: true
    },
    tenantId: {
        type: String,
        required: true,
        index: true
    },
    websiteUrl: {
        type: String,
        required: true
    },
    
    status: {
        type: String,
        enum: ['started', 'crawling', 'crawling_complete', 'analyzing', 'analysis_complete', 
               'building', 'mapping', 'completed', 'failed'],
        default: 'started'
    },
    
    progress: {
        step: String,
        percentage: Number,
        message: String,
        details: mongoose.Schema.Types.Mixed
    },
    
    options: mongoose.Schema.Types.Mixed,
    
    // Results (populated on completion)
    results: {
        success: Boolean,
        businessType: String,
        confidence: Number,
        featuresEnabled: [String],
        knowledgeItems: Number,
        pagesProcessed: Number,
        error: String
    },
    
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    },
    completedAt: Date
}, {
    timestamps: true,
    collection: 'training_sessions'
});

// Crawl Job Metrics Schema
const CrawlJobMetricsSchema = new mongoose.Schema({
    jobId: {
        type: String,
        required: true,
        index: true
    },
    tenantId: {
        type: String,
        required: true,
        index: true
    },
    
    status: {
        type: String,
        enum: ['completed', 'failed', 'timeout'],
        required: true
    },
    
    businessType: String,
    
    // Timing
    queuedAt: Date,
    startedAt: Date,
    completedAt: Date,
    
    // Performance
    duration: Number, // milliseconds
    retries: {
        type: Number,
        default: 0
    },
    
    // Results
    result: mongoose.Schema.Types.Mixed,
    
    // Metrics
    metrics: {
        pagesProcessed: Number,
        changesDetected: Number,
        newKnowledgeItems: Number,
        errorsEncountered: Number
    },
    
    createdAt: {
        type: Date,
        default: Date.now,
        index: { expireAfterSeconds: 2592000 } // 30 days TTL
    }
}, {
    collection: 'crawl_job_metrics'
});

// Scheduler Metrics Schema
const SchedulerMetricsSchema = new mongoose.Schema({
    timestamp: {
        type: Date,
        default: Date.now,
        index: { expireAfterSeconds: 604800 } // 7 days TTL
    },
    
    active_jobs: Number,
    queued_jobs: Number,
    scheduler_running: Boolean,
    
    queue_stats: {
        total: Number,
        by_business_type: mongoose.Schema.Types.Mixed,
        avg_queue_time: Number
    },
    
    system: {
        max_concurrent_jobs: Number,
        crawl_intervals: mongoose.Schema.Types.Mixed,
        uptime: Number,
        memory_usage: Number,
        cpu_usage: Number
    },
    
    // Hourly aggregated data
    jobs_completed_last_hour: Number,
    jobs_failed_last_hour: Number,
    avg_job_duration_last_hour: Number
}, {
    collection: 'scheduler_metrics'
});

// Knowledge Base Items Schema (for search optimization)
const KnowledgeBaseItemSchema = new mongoose.Schema({
    tenantId: {
        type: String,
        required: true,
        index: true
    },
    
    itemId: {
        type: String,
        required: true,
        index: true
    },
    
    type: {
        type: String,
        enum: ['faq', 'contact', 'hours', 'service', 'product', 'policy'],
        required: true
    },
    
    category: String,
    question: String,
    answer: {
        type: String,
        required: true
    },
    
    keywords: [String],
    source: {
        type: String,
        required: true
    },
    sourceUrl: String,
    
    confidence: {
        type: Number,
        min: 0,
        max: 1,
        default: 0.8
    },
    
    autoGenerated: {
        type: Boolean,
        default: true
    },
    
    // Searchability
    searchVector: mongoose.Schema.Types.Mixed, // For vector search if needed
    
    // Usage tracking
    accessCount: {
        type: Number,
        default: 0
    },
    lastAccessed: Date,
    
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    collection: 'knowledge_base_items'
});

// Create compound indexes for performance
TenantTrainingDataSchema.index({ tenantId: 1, status: 1 });
TenantTrainingDataSchema.index({ 'businessAnalysis.detectedType': 1 });
TenantTrainingDataSchema.index({ trainedAt: 1 });
TenantTrainingDataSchema.index({ autoGenerated: 1, updatedAt: 1 });

TrainingSessionSchema.index({ tenantId: 1, status: 1 });
TrainingSessionSchema.index({ status: 1, createdAt: 1 });

CrawlJobMetricsSchema.index({ tenantId: 1, createdAt: -1 });
CrawlJobMetricsSchema.index({ status: 1, businessType: 1 });

KnowledgeBaseItemSchema.index({ tenantId: 1, type: 1 });
KnowledgeBaseItemSchema.index({ tenantId: 1, category: 1 });
KnowledgeBaseItemSchema.index({ keywords: 1 });
KnowledgeBaseItemSchema.index({ question: 'text', answer: 'text' }); // Text search

// Pre-save middleware to update timestamps
TenantTrainingDataSchema.pre('save', function(next) {
    this.updatedAt = new Date();
    next();
});

TrainingSessionSchema.pre('save', function(next) {
    this.updatedAt = new Date();
    next();
});

KnowledgeBaseItemSchema.pre('save', function(next) {
    this.updatedAt = new Date();
    next();
});

// Create models
const TenantTrainingData = mongoose.model('TenantTrainingData', TenantTrainingDataSchema);
const TrainingSession = mongoose.model('TrainingSession', TrainingSessionSchema);
const CrawlJobMetrics = mongoose.model('CrawlJobMetrics', CrawlJobMetricsSchema);
const SchedulerMetrics = mongoose.model('SchedulerMetrics', SchedulerMetricsSchema);
const KnowledgeBaseItem = mongoose.model('KnowledgeBaseItem', KnowledgeBaseItemSchema);

// Database initialization utility
class AutoTrainingDB {
    /**
     * Initialize database indexes and collections
     */
    static async initialize() {
        try {
            console.log('🗄️ Initializing auto-training database schemas...');

            // Ensure indexes are created
            await TenantTrainingData.createIndexes();
            await TrainingSession.createIndexes();
            await CrawlJobMetrics.createIndexes();
            await SchedulerMetrics.createIndexes();
            await KnowledgeBaseItem.createIndexes();

            // Create any additional custom indexes
            await this.createCustomIndexes();

            console.log('✅ Auto-training database schemas initialized successfully');

        } catch (error) {
            console.error('❌ Failed to initialize auto-training database schemas:', error);
            throw error;
        }
    }

    /**
     * Create custom database indexes for performance optimization
     */
    static async createCustomIndexes() {
        try {
            const db = mongoose.connection.db;

            // Helper function to safely create indexes
            const safeCreateIndex = async (collection, indexSpec, options = {}) => {
                try {
                    await db.collection(collection).createIndex(indexSpec, options);
                } catch (error) {
                    if (error.code === 85 || error.message.includes('equivalent index already exists')) {
                        console.log(`ℹ️ Index already exists for ${collection}, skipping...`);
                    } else {
                        console.warn(`⚠️ Could not create index for ${collection}:`, error.message);
                    }
                }
            };

            // Compound index for tenant training data queries
            await safeCreateIndex('tenant_training_data', {
                tenantId: 1,
                'businessAnalysis.detectedType': 1,
                trainedAt: -1
            });

            // Index for efficient job scheduling queries
            await safeCreateIndex('tenant_training_data', {
                autoGenerated: 1,
                trainedAt: 1,
                'tenantConfig.businessType': 1
            });

            // Geospatial index if location data is present
            await safeCreateIndex('tenant_training_data', {
                'knowledgeBase.contactInfo.location': '2dsphere'
            });

            // Check if text search index already exists before creating
            try {
                const existingIndexes = await db.collection('knowledge_base_items').listIndexes().toArray();
                const hasTextIndex = existingIndexes.some(index => 
                    index.name && (index.name.includes('text') || index.name.includes('knowledge_text_search'))
                );
                
                if (!hasTextIndex) {
                    // Full text search index for knowledge base
                    await safeCreateIndex('knowledge_base_items', {
                        question: 'text',
                        answer: 'text',
                        keywords: 'text'
                    }, {
                        weights: {
                            question: 10,
                            answer: 5,
                            keywords: 1
                        },
                        name: 'knowledge_text_search'
                    });
                } else {
                    console.log('ℹ️ Text search index already exists for knowledge_base_items, skipping...');
                }
            } catch (indexError) {
                console.warn('⚠️ Could not create or check text search index:', indexError.message);
            }

            console.log('✅ Custom indexes creation completed');

        } catch (error) {
            console.warn('⚠️ Some custom indexes could not be created:', error.message);
        }
    }

    /**
     * Get database statistics
     */
    static async getStats() {
        try {
            const stats = {
                collections: {
                    tenant_training_data: await TenantTrainingData.countDocuments(),
                    training_sessions: await TrainingSession.countDocuments(),
                    crawl_job_metrics: await CrawlJobMetrics.countDocuments(),
                    scheduler_metrics: await SchedulerMetrics.countDocuments(),
                    knowledge_base_items: await KnowledgeBaseItem.countDocuments()
                },
                
                business_types: await TenantTrainingData.aggregate([
                    { $group: { 
                        _id: '$businessAnalysis.detectedType', 
                        count: { $sum: 1 } 
                    }}
                ]),
                
                training_status: await TenantTrainingData.aggregate([
                    { $group: { 
                        _id: '$status', 
                        count: { $sum: 1 } 
                    }}
                ]),
                
                recent_activity: {
                    sessions_last_24h: await TrainingSession.countDocuments({
                        createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
                    }),
                    jobs_last_24h: await CrawlJobMetrics.countDocuments({
                        createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) }
                    })
                }
            };

            return stats;

        } catch (error) {
            console.error('Error getting database stats:', error);
            throw error;
        }
    }

    /**
     * Clean up old data based on retention policies
     */
    static async cleanup() {
        try {
            console.log('🧹 Running database cleanup...');

            const now = new Date();
            const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
            const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

            // Clean old failed training sessions
            const deletedSessions = await TrainingSession.deleteMany({
                status: 'failed',
                createdAt: { $lt: sevenDaysAgo }
            });

            // Clean old job metrics (TTL should handle this, but backup cleanup)
            const deletedMetrics = await CrawlJobMetrics.deleteMany({
                createdAt: { $lt: thirtyDaysAgo }
            });

            // Clean orphaned knowledge base items
            const orphanedItems = await KnowledgeBaseItem.deleteMany({
                tenantId: { $nin: await TenantTrainingData.distinct('tenantId') }
            });

            console.log(`✅ Cleanup completed:`, {
                deletedSessions: deletedSessions.deletedCount,
                deletedMetrics: deletedMetrics.deletedCount,
                orphanedItems: orphanedItems.deletedCount
            });

        } catch (error) {
            console.error('❌ Database cleanup failed:', error);
            throw error;
        }
    }
}

// Export models and utilities
module.exports = {
    // Models
    TenantTrainingData,
    TrainingSession,
    CrawlJobMetrics,
    SchedulerMetrics,
    KnowledgeBaseItem,
    
    // Schemas (for reference)
    TenantTrainingDataSchema,
    TrainingSessionSchema,
    CrawlJobMetricsSchema,
    SchedulerMetricsSchema,
    KnowledgeBaseItemSchema,
    
    // Database utilities
    AutoTrainingDB
};
