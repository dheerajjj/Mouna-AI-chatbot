/**
 * AutoTrainingService - Automatic Website Crawling and Chatbot Training
 * 
 * This service automatically crawls customer websites, extracts business information,
 * detects business type, and trains the chatbot with zero manual setup.
 */

const WebsiteCrawler = require('./crawling/WebsiteCrawler');
const BusinessTypeDetector = require('./ai/BusinessTypeDetector');
const KnowledgeBaseBuilder = require('./ai/KnowledgeBaseBuilder');
const FeatureMapper = require('./ai/FeatureMapper');
const DatabaseService = require('./DatabaseService');
const { v4: uuidv4 } = require('uuid');

class AutoTrainingService {
    constructor() {
        this.crawler = new WebsiteCrawler();
        this.businessDetector = new BusinessTypeDetector();
        this.knowledgeBuilder = new KnowledgeBaseBuilder();
        this.featureMapper = new FeatureMapper();
        this.db = new DatabaseService();
    }

    /**
     * Bootstrap a new tenant with automatic website training
     * @param {string} websiteUrl - Customer's website URL
     * @param {string} tenantId - Tenant ID
     * @param {Object} options - Optional configuration
     * @returns {Object} Training results and tenant configuration
     */
    async bootstrapTenant(websiteUrl, tenantId, options = {}) {
        console.log(`ðŸš€ Starting auto-training for tenant: ${tenantId}, website: ${websiteUrl}`);
        
        try {
            // Create training session
            const sessionId = uuidv4();
            await this.createTrainingSession(sessionId, tenantId, websiteUrl);

            // Step 1: Crawl and extract website data
            console.log('ðŸ“¡ Crawling website...');
            const crawlResults = await this.crawler.crawlWebsite(websiteUrl, {
                maxPages: options.maxPages || 20,
                includeImages: true,
                followSitemap: true,
                timeout: 30000
            });

            await this.updateTrainingProgress(sessionId, 'crawling_complete', crawlResults);

            // Step 2: Detect business type and extract structured data
            console.log('ðŸ” Analyzing business type...');
            const businessAnalysis = await this.businessDetector.analyzeWebsite(crawlResults);
            
            await this.updateTrainingProgress(sessionId, 'analysis_complete', businessAnalysis);

            // Step 3: Build knowledge base from extracted data
            console.log('ðŸ§  Building knowledge base...');
            const knowledgeBase = await this.knowledgeBuilder.buildFromWebsiteData(
                crawlResults,
                businessAnalysis,
                { generateFAQs: true, extractContactInfo: true }
            );

            // Step 4: Auto-enable features based on business type
            console.log('âš™ï¸ Configuring tenant features...');
            const tenantConfig = await this.featureMapper.mapBusinessToFeatures(
                businessAnalysis,
                knowledgeBase
            );

            // Step 5: Save everything to database
            console.log('ðŸ’¾ Saving training results...');
            await this.saveTenantTrainingData(tenantId, {
                crawlResults,
                businessAnalysis,
                knowledgeBase,
                tenantConfig,
                sessionId,
                websiteUrl,
                trainedAt: new Date(),
                autoGenerated: true
            });

            // Step 6: Update tenant configuration
            await this.updateTenantConfiguration(tenantId, tenantConfig);

            await this.updateTrainingProgress(sessionId, 'completed', {
                success: true,
                businessType: businessAnalysis.detectedType,
                featuresEnabled: Object.keys(tenantConfig.enabledFeatures).filter(f => tenantConfig.enabledFeatures[f]),
                knowledgeItems: knowledgeBase.items.length,
                pagesProcessed: crawlResults.pages.length
            });

            console.log(`âœ… Auto-training completed successfully for ${tenantId}`);

            return {
                success: true,
                sessionId,
                businessType: businessAnalysis.detectedType,
                confidence: businessAnalysis.confidence,
                featuresEnabled: tenantConfig.enabledFeatures,
                knowledgeItems: knowledgeBase.items.length,
                pagesProcessed: crawlResults.pages.length,
                tenantConfig,
                trainingData: {
                    businessInfo: businessAnalysis.extractedInfo,
                    contactInfo: knowledgeBase.contactInfo,
                    mainServices: knowledgeBase.services || [],
                    faqs: knowledgeBase.faqs || []
                }
            };

        } catch (error) {
            console.error(`âŒ Auto-training failed for ${tenantId}:`, error);
            await this.updateTrainingProgress(sessionId, 'failed', { 
                error: error.message,
                stack: error.stack 
            });
            
            throw new Error(`Auto-training failed: ${error.message}`);
        }
    }

    /**
     * Re-crawl and update existing tenant data
     * @param {string} tenantId - Tenant ID
     * @param {Object} options - Update options
     * @returns {Object} Update results
     */
    async refreshTenantData(tenantId, options = {}) {
        console.log(`ðŸ”„ Refreshing data for tenant: ${tenantId}`);

        try {
            // Get existing tenant data
            const existingData = await this.getTenantTrainingData(tenantId);
            if (!existingData || !existingData.websiteUrl) {
                throw new Error('No existing training data found for tenant');
            }

            // Re-crawl with incremental updates
            const crawlResults = await this.crawler.crawlWebsite(existingData.websiteUrl, {
                maxPages: options.maxPages || 15,
                lastCrawlDate: existingData.lastUpdated,
                compareWithPrevious: true
            });

            // Check if significant changes detected
            const hasSignificantChanges = await this.detectSignificantChanges(
                existingData.crawlResults,
                crawlResults
            );

            if (!hasSignificantChanges && !options.forceUpdate) {
                console.log('â„¹ï¸ No significant changes detected, skipping update');
                return {
                    success: true,
                    updated: false,
                    reason: 'No significant changes detected',
                    lastChecked: new Date()
                };
            }

            // Perform incremental update
            const updateResults = await this.performIncrementalUpdate(
                tenantId,
                existingData,
                crawlResults
            );

            return {
                success: true,
                updated: true,
                changes: updateResults.changes,
                newKnowledgeItems: updateResults.newItems,
                updatedAt: new Date()
            };

        } catch (error) {
            console.error(`âŒ Refresh failed for ${tenantId}:`, error);
            throw error;
        }
    }

    /**
     * Get training status for a tenant
     * @param {string} tenantId - Tenant ID
     * @returns {Object} Training status
     */
    async getTrainingStatus(tenantId) {
        try {
            const trainingData = await this.getTenantTrainingData(tenantId);
            const activeSessions = await this.getActiveTrainingSessions(tenantId);

            return {
                hasTraining: !!trainingData,
                isTraining: activeSessions.length > 0,
                lastTrained: trainingData?.trainedAt,
                businessType: trainingData?.businessAnalysis?.detectedType,
                knowledgeItems: trainingData?.knowledgeBase?.items?.length || 0,
                autoGenerated: trainingData?.autoGenerated || false,
                websiteUrl: trainingData?.websiteUrl,
                activeSessions: activeSessions.map(s => ({
                    sessionId: s.sessionId,
                    status: s.status,
                    startedAt: s.createdAt,
                    progress: s.progress
                }))
            };
        } catch (error) {
            console.error(`Error getting training status for ${tenantId}:`, error);
            return {
                hasTraining: false,
                isTraining: false,
                error: error.message
            };
        }
    }

    /**
     * Schedule automatic re-crawling for all tenants
     * @param {Object} options - Scheduling options
     */
    async scheduleAutomaticUpdates(options = {}) {
        console.log('ðŸ“… Scheduling automatic tenant updates...');
        
        const tenants = await this.getTenantsWithAutoTraining();
        const updateInterval = options.intervalDays || 7; // Weekly by default

        for (const tenant of tenants) {
            const daysSinceLastUpdate = this.getDaysSinceLastUpdate(tenant.lastUpdated);
            
            if (daysSinceLastUpdate >= updateInterval) {
                console.log(`Scheduling update for tenant: ${tenant.tenantId}`);
                
                // Queue update job (using your existing job queue system)
                await this.queueTenantUpdate(tenant.tenantId, {
                    priority: 'normal',
                    maxRetries: 3,
                    scheduledFor: new Date(Date.now() + Math.random() * 3600000) // Spread over 1 hour
                });
            }
        }
    }

    // Private helper methods

    async createTrainingSession(sessionId, tenantId, websiteUrl) {
        const session = {
            sessionId,
            tenantId,
            websiteUrl,
            status: 'started',
            progress: { step: 'initializing', percentage: 0 },
            createdAt: new Date(),
            updatedAt: new Date()
        };

        await this.db.collection('training_sessions').insertOne(session);
    }

    async updateTrainingProgress(sessionId, status, data = {}) {
        const update = {
            status,
            progress: data,
            updatedAt: new Date()
        };

        if (status === 'completed' || status === 'failed') {
            update.completedAt = new Date();
        }

        await this.db.collection('training_sessions').updateOne(
            { sessionId },
            { $set: update }
        );
    }

    async saveTenantTrainingData(tenantId, trainingData) {
        const document = {
            tenantId,
            ...trainingData,
            createdAt: new Date(),
            updatedAt: new Date()
        };

        await this.db.collection('tenant_training_data').replaceOne(
            { tenantId },
            document,
            { upsert: true }
        );
    }

    async getTenantTrainingData(tenantId) {
        return await this.db.collection('tenant_training_data').findOne({ tenantId });
    }

    async updateTenantConfiguration(tenantId, config) {
        // Update the main tenant configuration
        await this.db.collection('tenants').updateOne(
            { tenantId },
            {
                $set: {
                    configuration: config,
                    autoConfigured: true,
                    lastAutoUpdate: new Date(),
                    updatedAt: new Date()
                }
            },
            { upsert: true }
        );
    }

    async getActiveTrainingSessions(tenantId) {
        return await this.db.collection('training_sessions')
            .find({ 
                tenantId, 
                status: { $in: ['started', 'crawling', 'analyzing', 'building'] } 
            })
            .toArray();
    }

    async detectSignificantChanges(oldData, newData) {
        // Simple change detection - can be enhanced with more sophisticated algorithms
        if (!oldData || !oldData.pages) return true;

        const oldPageCount = oldData.pages.length;
        const newPageCount = newData.pages.length;
        const pageCountDiff = Math.abs(oldPageCount - newPageCount) / oldPageCount;

        // Consider significant if 20% of pages changed or new pages added/removed
        return pageCountDiff > 0.2;
    }

    async performIncrementalUpdate(tenantId, existingData, newCrawlResults) {
        // Analyze what changed
        const changes = {
            newPages: [],
            modifiedPages: [],
            removedPages: []
        };

        // Build updated knowledge base with only changed content
        const updatedKnowledge = await this.knowledgeBuilder.buildIncremental(
            existingData.knowledgeBase,
            newCrawlResults,
            changes
        );

        // Save incremental update
        await this.saveTenantTrainingData(tenantId, {
            ...existingData,
            crawlResults: newCrawlResults,
            knowledgeBase: updatedKnowledge,
            lastUpdated: new Date(),
            updateType: 'incremental'
        });

        return {
            changes,
            newItems: updatedKnowledge.newItems || []
        };
    }

    async getTenantsWithAutoTraining() {
        return await this.db.collection('tenant_training_data')
            .find({ autoGenerated: true })
            .toArray();
    }

    getDaysSinceLastUpdate(lastUpdated) {
        if (!lastUpdated) return Infinity;
        const now = new Date();
        const diffTime = Math.abs(now - new Date(lastUpdated));
        return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    }

    async queueTenantUpdate(tenantId, options) {
        // Implementation depends on your job queue system
        // This is a placeholder for job scheduling
        console.log(`Queued update for tenant ${tenantId} with options:`, options);
    }
}

module.exports = AutoTrainingService;
